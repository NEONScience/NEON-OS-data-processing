% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/removeDupsPDR.R
\name{removeDups}
\alias{removeDups}
\alias{removeDups.L1}
\title{Remove duplicates from a data table based on a provided primary key; flag duplicates that can't be removed.}
\usage{
removeDups(data, variables, table)

removeDups.L1(
  tab = NA,
  L1Data = data.frame(),
  pubWB = data.frame(),
  tableName = NA,
  stack = "prod",
  ...
)
}
\arguments{
\item{data}{For use with removeDups. A data frame containing data from a NEON observational data table [data frame]}

\item{variables}{For use with removeDups. The NEON variables file containing metadata about the data table in question [data frame]}

\item{table}{For use with removeDups. The name of the table. Must match one of the table names in 'variables' [character]}

\item{tab}{For use with removeDups.L1(). Name of table for which to get data, in the form DP#.#####.001:table_name_in. Defaults to NA, # [character]}

\item{L1Data}{For use with removeDups.L1(). L1 data, a data.frame or tibble}

\item{pubWB}{For use with removeDups.L1(). Pub workbook, a data.frame or tibble.}

\item{tableName}{For use with removeDups.L1(). A pub table name [character]}

\item{stack}{For use with removeDups.L1(). Stack to query if using restR. Can be one of 'int','cert', or 'prod'. Defaults to 'prod'}

\item{...}{For use with removeDups.L1(). Other options passed to restR::get.os.l1.by.tab.all.opts(), use ?restR::get.os.l1.by.tab.all.opts for argument descriptions}
}
\value{
A modified data frame with duplicates removed and a flag field added and populated.
}
\description{
NEON observational data may contain duplicates; this function removes exact duplicates, attempts to resolve non-exact duplicates, and flags duplicates that can't be resolved.
}
\details{
Duplicates are identified based on exact matches in the values of the primary key. For records with identical keys, these steps are followed, in order: (1) If records are identical except for NA or empty string values, the non-NA values are kept. (2) If records are identical except for uid, remarks, and/or personnel (xxxxBy) fields, unique values are concatenated within each field, and the merged version is kept. (3) For records that are identical following steps 1 and 2, one record is kept and flagged with duplicateRecordQF=1. (4) Records that can't be resoved by steps 1-3 are flagged with duplicateRecordQF=2. Note that in a set of three or more duplicates, some records may be resolveable and some may not; if two or more records are left after steps 1-3, all remaining records are flagged with duplicateRecordQF=2.
}
\section{Functions}{
\itemize{
\item \code{removeDups.L1}: method to work with L1 data from PDR
}}

\examples{

\dontrun{

# using removeDups.L1, example 1 -- 
# pulling L1 data from restR within the function and then checking for dups

mam_perplotnight_pub__dups_flagged_ex1 <- removeDups.L1(
  tab = 'DP1.10072.001:mam_perplotnight_pub', 
  tableName = NA, #maps to table #optional
  minStartDate = '2020-01-01',
  maxStartDate = '2020-01-31')


# using removeDups.L1, example 2 -- 
# sending L1 data to fxn, but pulling pubWB from restR

# get L1 data
my_L1_data <- restR::get.os.l1.by.tab.all.opts(
  tab = 'DP1.10072.001:mam_perplotnight_pub',
  inclSamples = 'true',
  minStartDate = '2020-01-01',
  maxStartDate = '2020-01-31')

# send L1 data to dup check function, get putwb using restR
mam_perplotnight_pub__dups_flagged_ex2 <- removeDups.L1(
  tab = 'DP1.10072.001:mam_perplotnight_pub', 
  L1Data = my_L1_data) 


# using removeDups.L1, example 3 -- 
# sending L1 data and pub wb to fxn, using tab argument

# get L1 data
my_L1_data <- restR::get.os.l1.by.tab.all.opts(
  tab = 'DP1.10072.001:mam_perplotnight_pub',
  inclSamples = 'true',
  minStartDate = '2020-01-01',
  maxStartDate = '2020-01-31')

# get pubWB
my_pubWB <- restR::get.pub.workbook(
  DPID = 'DP1.10072.001', 
  table = 'mam_perplotnight_pub', 
  stack = 'prod')
 
# send L1 data to dup check function, get putwb using restR
mam_perplotnight_pub__dups_flagged_ex3 <- removeDups.L1(
  tab = 'DP1.10072.001:mam_perplotnight_pub', 
  pubWB = my_pubWB,
  L1Data = my_L1_data) 


# using removeDups.L1, example 4 -- 
# sending L1 data and pub wb to fxn, using tableName argument

# get L1 data
my_L1_data <- restR::get.os.l1.by.tab.all.opts(
  tab = 'DP1.10072.001:mam_perplotnight_pub',
  inclSamples = 'true',
  minStartDate = '2020-01-01',
  maxStartDate = '2020-01-31')

# get pubWB
my_pubWB <- restR::get.pub.workbook(
  DPID = 'DP1.10072.001', 
  table = 'mam_perplotnight_pub', 
  stack = 'prod')

# send L1 data to dup check function, get putwb using restR
mam_perplotnight_pub__dups_flagged_ex4 <- removeDups.L1(
  tableName = 'mam_perplotnight_pub',
  pubWB = my_pubWB,
  L1Data = my_L1_data) 


# using removeDups.L1, example 5 -- 
# should error out, you need to send either 'tab' or 'tableName'

# get L1 data
my_L1_data <- restR::get.os.l1.by.tab.all.opts(
  tab = 'DP1.10072.001:mam_perplotnight_pub',
  inclSamples = 'true',
  minStartDate = '2020-01-01',
  maxStartDate = '2020-01-31')

# get pubWB
my_pubWB <- restR::get.pub.workbook(
  DPID = 'DP1.10072.001', 
  table = 'mam_perplotnight_pub', 
  stack = 'prod')

# send L1 data to dup check function, get putwb using restR
mam_perplotnight_pub__dups_flagged_ex5 <- removeDups.L1(
  pubWB = my_pubWB,
  L1Data = my_L1_data) 


# using removeDups.L1, example 5 -- 
# should error out, you need to send arguments to get L1 data or L1Data

# get pubWB
my_pubWB <- restR::get.pub.workbook(
  DPID = 'DP1.10072.001', 
  table = 'mam_perplotnight_pub', 
  stack = 'prod')

# send L1 data to dup check function, get putwb using restR
mam_perplotnight_pub__dups_flagged_ex6 <- removeDups.L1(
  tableName = 'mam_perplotnight_pub',
  pubWB = my_pubWB) 
#' 
}#END DONTRUN
}
\references{
License: GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007
}
\author{
Claire Lunch \email{clunch@battelleecology.org}
Eric Sokol \email{esokol@battelleecology.org}
}
